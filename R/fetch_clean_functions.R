#' Return a list of data frames generated from the servosphere
#'
#' Import all the .csv files in a single directory and convert
#' them to a list of data frames
#'
#' When using the servosphere, each trial produces a .csv file that contains the
#' data from that trial. This data should include a column for time (dT),
#' position (dX, dY), and the stimulus. All the data files the user wishes to
#' analyze should be in the same directory. They should also have a common
#' naming convention to facilitate the identification of these files (i.e.
#' "x_servosphere.csv", where x might be the date the trial was run or the
#' unique trial ID).
#'
#' Other functions in this package require that all the .csv files from the
#' servosphere that the user wishes to analyze are contained in a list, where
#' each item in the list is a data.table created from each .csv file.
#'
#' This function makes use of the data.table package to read in the .csv files,
#' as it is currently the fastest way to bring in such files. This function is
#' noticeably slower using alternatives when the number of .csv files is large.
#'
#' @param path A string for the file path.
#' @param pattern A string with a unique pattern to look for in file names.
#' @param full.names Return the full file path when TRUE or the file name when FALSE.
#' @return A list where each item is a data.table
#' @examples
#' getFiles("./data/", pattern = "_servosphere.csv")
#' @export

getFiles <- function(path, pattern, full.names = TRUE) {
   if (!is.character(path) | !is.character(pattern)){
      warning("Both path and pattern arguments must be strings.")
   }
   fullpath <- list.files(path = path, pattern = pattern, full.names = TRUE)
   dat <- purrr::map(fullpath, data.table::fread) # maybe import (export?) fread
   dat <- purrr::map(dat, as.data.frame)
}

#' Set column names for list of data frames
#'
#' Take a list of data frames and change the column names
#'
#' Once a list of data frames is generated with the getFiles function, use this
#' function to set up the column names for each all the data frames in the list.
#'
#' Other functions in this package require that there be columns named "dT",
#' "dx", and "dy". These name should be used for the change in time and distance
#' variables.
#'
#' @param list A list of data frame objects.
#' @param colnames A vector of strings holding the names for the columns.
#' @examples
#' colnames <- c("stimulus", "dT", "dx", "dy", "enc1", "enc2", "enc3")
#' cleanNames(dat_list, colnames)
#' @export

cleanNames <- function(list, colnames) {
   purrr::map_if(list, is.data.frame, setNames, colnames)
}

#' Thin data frames
#'
#' Thin the data frames in a list to reduce noise in movement recordings
#'
#' This function requires that the change in time and change in position column
#' names are "dT", "dx", and "dy", respectively.
#'
#' Movement recording data generated by the servosphere software is quite noisy
#' due to extraneous movements by the insect or side-to-side motion. Thinning
#' the data by aggregating rows reduces this noise. Thinning also reduces the
#' size of the data files, making future computing tasks faster.
#'
#' To thin the data properly, we recommend watching recordings of the target
#' organism moving on the servosphere and determine the length of time it takes
#' the insect to move at least 50% of its body length. Use the time it takes the
#' insect to move at least 50% of its body length as the minimum thinning time.
#' Longer periods may be necessary depending on the size and movement of the
#' insect.
#'
#' The resulting data frames will have an additional column named "length". The
#' values in length should be approximately equal to the sum of dT from the n
#' rows aggregated over, i.e. if each observation from the un-thinned data is 10
#' ms and the user aggregates these observations to 1 second, the value of
#' length should be approximately 1. Note that in thinning the data frame, the
#' stimulus column will also be thinned. The stimulus status value at the start
#' of the thinning will taken as the stimulus value for the aggregated data.
#'
#' @param list A list of data frame objects.
#' @param n The number of consecutive rows to aggregate over.
#' @return A list of thinned data frames with an additional column, length, to
#'   check that the function worked.
#' @export

thin <- function(list, n){
   purrr::map_if(list, is.data.frame, function(.x) {
      x <- cbind(aggregate(.x[, c("dT", "dx", "dy")],
                           list(rep(
                              1:(nrow(.x) %/% n + 1), each = n, len = nrow(.x)
                           )),
                           sum)[,-1],
                 aggregate(.x[, c("dT")],
                           list(rep(
                              1:(nrow(.x) %/% n + 1), each = n, len = nrow(.x)
                           )),
                           length)[,-1])
      colnames(x)[4] <- "length" # add length column
      x <- .x %>% # Add other identification columns corresponding to thinned
         select(names(.x)[!(names(.x) %in% names(x))]) %>% # rows
         .[seq(from = 1,
                to = nrow(.x),
                length.out = nrow(x)),
            ] %>%
         bind_cols(x) %>%
         select(-enc1, -enc2, -enc3, id, dx, dy, everything()) %>%
         select(everything())

      return(x)
   })
}

#' Merge trial id information
#'
#' This function merges trial id information with the servosphere data.
#'
#' Users of the servosphere will need a separate data frame with trial id
#' information in a column titled `id`. This should contain a unique identifier
#' and any other relevant experimental information, such as treatments applied,
#' date, time of day, etc. Make sure the rows in your trial id data frame are
#' ordered in the same order as the list of data frames of your servosphere
#' output. If the dataframes should be split by stimulus, the trial record
#' dataframe should contain a column `id_stim` that lists the id number of the
#' trial, followed by an underscore, followed by each value of the stimulus
#' variable retained. In this case, the rows of the trial id dataframe should be
#' ordered by `id` in the same order as the list of dataframes first and within
#' unique `id` values, ordered numerically by the stimulus values to be
#' retained. This function will also append an item to your list of data frames
#' that contains the relevant column names to be retained in future
#' manipulations of the data.
#'
#' @param trial.data The data frame containing your trial id information. This
#'   must contain an identifier column titled `id` and if the data are to be
#'   split by stimuli, an additional identifier column `id_stim`. See the
#'   description for more details.
#' @param col.names A string vector containing the names of the columns you want
#'   to transfer to your servosphere output data.
#' @param list The list of servosphere output data.
#' @param stimulus.split A logical value indicating whether the dataframes
#'   should be split by stimulus. Defaults to `FALSE`. If `TRUE`, be sure to
#'   include a `id_stim` column to give each trial/stimulus combination a unique
#'   ID.
#' @param stimulus.keep An integer vector containing the stimuli numbers to
#'   retain in the data and split the dataframes by. Omitted stimuli values will
#'   be discarded.
#' @export

mergeTrialInfo <- function(trial.data,
                           col.names,
                           list,
                           stimulus.split = FALSE,
                           stimulus.keep) {

   if (stimulus.split == TRUE) {
      id <- unique(trial.data$id)
      list.id <- lapply(as.list(1:length(id)),
                                function(x) x[[1]])
      list <- map2(list, list.id, function(.x, .y) {
         .y <- rep(.y, each = nrow(.x))
         .x <- .x %>% mutate(id = .y)
         return(.x)
      })
      out <- purrr::map_if(list, is.data.frame, function(.x) {
         .x %>%
            filter(stimulus %in% stimulus.keep) %>%
            mutate(id_stim = as.character(paste0(id, "_", stimulus))) %>%
            split(.$stimulus)
      })
      out <- flatten(out)
      list.names <- map_chr(out, function(.x) {
         .x$id_stim[1]
      })
      names(out) <- list.names
      trial.data <- dplyr::select(trial.data, col.names)
      list.trial.data <- lapply(as.list(1:dim(trial.data)[1]),
                                function(x) trial.data[x[1], ])
      list <- map2(out, list.trial.data, function(.x, .y) {
         .y <- .y[rep(1, each = nrow(.x)), ]
         .x <- bind_cols(.x, .y)
         return(.x)
      })
      list[["col.names"]] <- c("id_stim", col.names)

   } else {
   trial.data <- dplyr::select(trial.data, col.names)
   list.trial.data <- lapply(as.list(1:dim(trial.data)[1]),
                                     function(x) trial.data[x[1], ])
   list <- map2(list, list.trial.data, function(.x, .y) {
      .y <- .y[rep(1, each = nrow(.x)), ]
      .x <- bind_cols(.x, .y)
      return(.x)
      })
   list[["col.names"]] <- c("id", col.names)
   }

   return(list)
}
