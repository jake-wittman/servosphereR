#' Return a list of data frames generated from the servosphere
#'
#' Import all the .csv files in a single directory and convert
#' them to a list of data frames
#'
#' When using the servosphere, each trial produces a .csv file that contains the
#' data from that trial. This data should include a column for time (dT),
#' position (dX, dY), and the stimulus. All the data files the user wishes to
#' analyze should be in the same directory. They should also have a common
#' naming convention to facilitate the identification of these files (i.e.
#' "x_servosphere.csv", where x might be the date the trial was run or the
#' unique trial ID).
#'
#' Other functions in this package require that all the .csv files from the
#' servosphere that the user wishes to analyze are contained in a list, where
#' each item in the list is a data.table created from each .csv file.
#'
#' This function makes use of the data.table package to read in the .csv files,
#' as it is currently the fastest way to bring in such files. This function is
#' noticeably slower using alternatives when the number of .csv files is large.
#'
#' @param path A string for the file path.
#' @param pattern A string with a unique pattern to look for in file names.
#' @param full.names Return the full file path when TRUE or the file name when FALSE.
#' @return A list where each item is a data.table
#' @examples
#' getFiles("./data/", pattern = "_servosphere.csv")
#' @export

getFiles <- function(path, pattern, full.names = TRUE) {
   if (!is.character(path) | !is.character(pattern)){
      warning("Both path and pattern arguments must be strings.")
   }
   fullpath <- list.files(path = path, pattern = pattern, full.names = TRUE)
   dat <- map(fullpath, data.table::fread) # maybe import (export?) fread
   dat <- map(dat, as.data.frame)
}

#' Set column names for list of data frames
#'
#' Take a list of data frames and change the column names
#'
#' Once a list of data frames is generated with the getFiles function, use this
#' function to set up the column names for each all the data frames in the list.
#'
#' @param list A list of data frame objects.
#' @param colnames A vector of strings holding the names for the columns.
#' @examples
#' colnames <- c("stimulus", "dT", "dx", "dy", "enc1", "enc2", "enc3")
#' cleanNames(dat_list, colnames)
#' @export

cleanNames <- function(list, colnames) {
   map(list, setNames, colnames)
}

#' Thin data frames
#'
#' Thin the data frames in a list to reduce noise in movement recordings
#'
#' This function requires that the change in time and change in position column
#' names are "dT", "dx", and "dy", respectively.
#'
#' Movement recording data generated by the servosphere software is quite noisy
#' due to extraneous movements by the insect or side-to-side motion. Thinning
#' the data by aggregating rows reduces this noise. Thinning also reduces the
#' size of the data files, making future computing tasks faster.
#'
#' To thin the data properly, we recommend watching recordings of the target
#' organism moving on the servosphere and determine the length of time it takes
#' the insect to move at least 50% of its body length. Use the time it takes the
#' insect to move at least 50% of its body length as the minimum thinning time.
#' Longer periods may be necessary depending on the size and movement of the
#' insect.
#'
#' The resulting data frames will have an additional column named "length". The
#' values in length should be approximately equal to the sum of dT from the n
#' rows aggregated over, i.e. if each observation from the un-thinned data is 10
#' ms and the user aggregates these observations to 1 second, the value of
#' length should be approximately 1.
#'
#' @param list A list of data frame objects.
#' @param n The number of consecutive rows to aggregate over.
#' @return A list of thinned data frames with an additional column, length, to
#'   check that the function worked.
#' @export

thin <- function(list, n){
   map(list, function(.x) {
      x <- cbind(aggregate(.x[, c("dT", "dx", "dy")],
                           list(rep(
                              1:(nrow(.x) %/% n + 1), each = n, len = nrow(.x)
                           )),
                           sum)[,-1],
                 aggregate(.x[, c("dT")],
                           list(rep(
                              1:(nrow(.x) %/% n + 1), each = n, len = nrow(.x)
                           )),
                           length)[,-1])
      colnames(x)[4] <- "length"
      return(x)
   })
}

