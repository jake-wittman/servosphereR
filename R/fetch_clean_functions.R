#' Return a list of data frames generated from the servosphere
#'
#' Import all the .csv files in a single directory and convert
#' them to a list of data frames
#'
#' When using the servosphere, each trial produces a .csv file that contains the
#' data from that trial. This data should include a column for time (dT),
#' position (dX, dY), and the stimulus. All the data files the user wishes to
#' analyze should be in the same directory. They should also have a common
#' naming convention to facilitate the identification of these files (i.e.
#' "x_servosphere.csv", where x might be the date the trial was run or the
#' unique trial ID).
#'
#' Other functions in this package require that all the .csv files from the
#' servosphere that the user wishes to analyze are contained in a list, where
#' each item in the list is a data.table created from each .csv file.
#'
#' This function makes use of the data.table package to read in the .csv files,
#' as it is currently the fastest way to bring in such files. This function is
#' noticeably slower when alternative csv reading functions are used and when
#' the number of .csv files is large.
#'
#' @param path A string for the file path.
#' @param pattern A string with a unique pattern to look for in file names.
#' @param full.names Return the full file path when TRUE or the file name when
#'   FALSE.
#' @return A list where each item is a data.table
#' @examples
#' getFiles("./data/", pattern = "_servosphere.csv")
#' @export

getFiles <- function(path, pattern, full.names = TRUE) {
   if (!is.character(path) | !is.character(pattern)){
      warning("Both path and pattern arguments must be strings.")
   }
   fullpath <- list.files(path = path, pattern = pattern, full.names = TRUE)
   dat <- purrr::map(fullpath, data.table::fread)
   dat <- purrr::map(dat, as.data.frame)
}

#' Set column names for list of data frames
#'
#' Take a list of data frames and change the column names
#'
#' Once a list of data frames is generated with the getFiles function, use this
#' function to set up the column names for all the data frames in the list.
#'
#' Other functions in this package require that the change in time and position
#' columns are named "dT", "dx", and "dy", respectively.
#'
#' @param list A list of data frame objects.
#' @param colnames A vector of strings holding the names for the columns.
#' @return Returns the list of data frames provided with the column names
#'   modified based on the provided vector \code{colnames}.
#' @examples
#' colnames <- c("stimulus", "dT", "dx", "dy", "enc1", "enc2", "enc3")
#' cleanNames(dat_list, colnames)
#' @export

cleanNames <- function(list, colnames) {
   purrr::map_if(list, is.data.frame, setNames, colnames)
}

#' Thin data frames
#'
#' Thin the data frames in a list to reduce noise in movement recordings
#'
#' This function requires that the change in time and change in position column
#' names are "dT", "dx", and "dy", respectively.
#'
#' Movement recording data generated by the servosphere software is quite noisy
#' due to extraneous movements by the insect or side-to-side motion. Thinning
#' the data by aggregating rows reduces this noise. Thinning also reduces the
#' size of the data files, making future computing tasks faster.
#'
#' To thin the data properly, we recommend watching recordings of the target
#' organism moving on the servosphere and determine the length of time it takes
#' the insect to move at least 50% of its body length. Use the time it takes the
#' insect to move at least 50% of its body length as the minimum thinning time.
#' Longer periods may be necessary depending on the size and movement of the
#' insect.
#'
#' The resulting data frames will have an additional column named "length". The
#' values in length should be approximately equal to the sum of dT from the n
#' rows aggregated over, i.e. if each observation from the un-thinned data is 10
#' ms and the user aggregates these observations to 1 second, the value of
#' length should be approximately 1. Note that in thinning the data frame, the
#' stimulus column will also be thinned. The stimulus status value at the first
#' row to be aggregated will become the value of the stimulus for the aggregated
#' row.
#'
#' @param list A list of data frame objects.
#' @param n The number of consecutive rows to aggregate over.
#' @return A list of thinned data frames with an additional column,
#'   \code{length}, to check that the function worked.
#' @examples
#' dat <- thin(dat, n = 100) # Aggregates every 100 rows in each data frame.
#' dat <- thin(dat, n = 60) # Aggregates every 60 rows in each data frame.
#' @export
#' @import magrittr dplyr

thin <- function(list, n){
   purrr::map_if(list, is.data.frame, function(.x) {
      x <- cbind(aggregate(.x[, c("dT", "dx", "dy")],
                           list(rep(
                              1:(nrow(.x) %/% n + 1), each = n, len = nrow(.x)
                           )),
                           sum)[,-1],
                 aggregate(.x[, c("dT")],
                           list(rep(
                              1:(nrow(.x) %/% n + 1), each = n, len = nrow(.x)
                           )),
                           length)[,-1])
      colnames(x)[4] <- "length" # add length column
      x <- .x %>% # Add other identification columns corresponding to thinned
         select(names(.x)[!(names(.x) %in% names(x))]) %>% # rows
         .[seq(from = 1,
                to = nrow(.x),
                length.out = nrow(x)),
            ] %>%
         bind_cols(x) %>%
         select(-enc1, -enc2, -enc3, id, dx, dy, everything()) %>%
         select(everything())

      return(x)
   })
}

#' Merge trial id information
#'
#' This function merges trial id information with the servosphere data.
#'
#' Users of the servosphere will need a separate data frame with trial id
#' information in a column titled \code{id}. This should contain a unique
#' identifier and any other relevant experimental information, such as
#' treatments applied, date, time of day, etc. Make sure the rows in your trial
#' id data frame are ordered in the same order as the list of data frames of
#' your servosphere output.
#'
#' Researchers may wish to compare data before and after some stimulus has been
#' applied and this function allows the user to split their data into separate
#' data frames based on different values of the stimulus variable to facilitate
#' these comparison. If the data frames should be split by stimulus, the trial
#' record data frame should contain a column \code{id_stim} that lists the id
#' number of the trial, followed by an underscore, followed by each value of the
#' stimulus variable retained. If the data should be split by stimulus, the rows
#' of the trial id data frame should be ordered first by \code{id} in the same
#' order as their data is stored within the list. Once ordered by \code{id} the
#' trial data data frame should be further ordered within an \code{id} by
#' \code{stimulus} (i.e. id_stim 1_1 should come before id_stim 1_2).
#'
#' Data recorded during a particular stimuli may also be discarded if it is not
#' required for analysis. For example, recordings may begin with a five minute
#' adjustment period and the data associated with that period may not be used
#' for analysis. The stimulus recorded by the software during that five minute
#' adjustment period can be discarded by omitting that stimulus number from the
#' \code{stimulus.keep} argument.
#'
#' This function will also append an item to your list of data frames that
#' contains the relevant column names to be retained in future manipulations of
#' the data.
#'
#' @param list The list of servosphere output data.
#' @param trial.data The data frame containing your trial id information. This
#'   must contain an identifier column titled `id` and if the data are to be
#'   split by stimuli, an additional identifier column `id_stim`. See the
#'   description for more details.
#' @param col.names A string vector containing the names of the columns you want
#'   to transfer to your servosphere output data. The trial.data data frame may
#'   have columns not needed for the analysis, so the function asks the user to
#'   be explicit about which columns to retain.
#' @param stimulus.split A logical value indicating whether the data frames
#'   should be split by stimulus. Defaults to `FALSE`. If `TRUE`, be sure to
#'   include a `id_stim` column to give each trial/stimulus combination a unique
#'   ID.
#' @param stimulus.keep An integer vector containing the stimuli numbers to
#'   retain in the data and split the data frames by. Omitted stimuli values
#'   will be discarded.
#' @return Returns the list of data frames provided which have been merged with
#'   additional relevant trial information.
#' @examples
#' # Merge the columns \code{id}, \code{treatment}, and \code{date} from the
#' # trial_record data frame with all the data frames in our list \code{dat}.
#' dat <- mergeTrialInfo(dat, trial_record, c("id", "treatment", "date"))
#'
#' # Repeat of the merger above without retaining the \code{id} column while
#' # also splitting the data provided into separate data frames based on the
#' # different stimuli recorded, keeping only data associated with stimuli 1 and
#' # 2. Splitting based on stimulus requires a column in the trial.data data
#' # frame titled \code{id_stim}.
#' dat <- mergeTrialInfo(dat_stim_split,
#'  trial_id_split,
#'  c("treatment", "date"),
#'  stimulus.split = TRUE,
#'  stimulus.keep = c(1, 2))
#' @export
#' @import magrittr dplyr

mergeTrialInfo <- function(list,
                           trial.data,
                           col.names,
                           stimulus.split = FALSE,
                           stimulus.keep) {

   if (stimulus.split == TRUE) {
      id <- unique(trial.data$id)
      list.id <- lapply(as.list(1:length(id)),
                                function(x) x[[1]])
      list <- map2(list, list.id, function(.x, .y) {
         .y <- rep(.y, each = nrow(.x))
         .x <- .x %>% mutate(id = .y)
         return(.x)
      })
      out <- purrr::map_if(list, is.data.frame, function(.x) {
         .x %>%
            filter(stimulus %in% stimulus.keep) %>%
            mutate(id_stim = as.character(paste0(id, "_", stimulus))) %>%
            split(.$stimulus)
      })
      out <- flatten(out)
      list.names <- map_chr(out, function(.x) {
         .x$id_stim[1]
      })
      names(out) <- list.names
      trial.data <- dplyr::select(trial.data, col.names)
      list.trial.data <- lapply(as.list(1:dim(trial.data)[1]),
                                function(x) trial.data[x[1], ])
      list <- map2(out, list.trial.data, function(.x, .y) {
         .y <- .y[rep(1, each = nrow(.x)), ]
         .x <- bind_cols(.x, .y)
         return(.x)
      })
      list[["col.names"]] <- c("id_stim", col.names)

   } else {
   trial.data <- dplyr::select(trial.data, col.names)
   list.trial.data <- lapply(as.list(1:dim(trial.data)[1]),
                                     function(x) trial.data[x[1], ])
   list <- map2(list, list.trial.data, function(.x, .y) {
      .y <- .y[rep(1, each = nrow(.x)), ]
      .x <- bind_cols(.x, .y)
      return(.x)
      })
   list[["col.names"]] <- c("id", col.names)
   }

   return(list)
}
